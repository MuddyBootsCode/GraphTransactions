<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Basic Neo4j Transaction Animator</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/vis/4.21.0/vis.min.js"></script>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/vis/4.21.0/vis.min.css">
  <style>
    body {
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      margin: 0;
      padding: 0;
      color: #333;
      background-color: #f5f5f5;
    }
    
    .header {
      background-color: #2B7CE9;
      color: white;
      padding: 20px;
      box-shadow: 0 2px 5px rgba(0,0,0,0.1);
      text-align: center;
    }
    
    .header h1 {
      margin: 0;
      font-size: 24px;
    }
    
    .container {
      max-width: 1200px;
      margin: 20px auto;
      padding: 0 20px;
    }
    
    .graph-wrapper {
      display: flex;
      align-items: flex-start;
      margin-bottom: 20px;
    }
    
    .graph-container {
      height: 400px;
      border: 1px solid #ddd;
      background-color: white;
      position: relative;
      overflow: visible;
      flex: 1;
    }
    
    .graph-controls {
      position: static;
      display: flex;
      flex-direction: column;
      gap: 8px;
      z-index: 1000;
      pointer-events: auto;
      margin-left: 10px;
      align-self: center;
    }
    
    .button-container {
      display: flex;
      gap: 10px;
      margin: 20px 0;
      justify-content: center;
    }
    
    .navigation-buttons {
      display: flex;
      gap: 20px;
      justify-content: center;
      margin: 20px 0;
    }
    
    .control-buttons {
      display: flex;
      gap: 10px;
      justify-content: center;
      margin: 20px 0;
    }
    
    button {
      padding: 8px 16px;
      background-color: #2B7CE9;
      color: white;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      font-weight: bold;
    }
    
    button:hover {
      background-color: #1b5fbd;
    }
    
    .graph-control-btn {
      width: 36px;
      height: 36px;
      border-radius: 50%;
      background-color: white;
      border: 1px solid #ddd;
      color: #2B7CE9;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      font-size: 18px;
      font-weight: bold;
      box-shadow: 0 2px 5px rgba(0,0,0,0.2);
      transition: all 0.2s ease;
      padding: 0;
    }
    
    .graph-control-btn:hover {
      background-color: #f5f5f5;
      transform: scale(1.05);
    }
    
    .tooltip {
      position: relative;
      display: block;
    }
    
    .tooltip .tooltiptext {
      visibility: hidden;
      width: 100px;
      background-color: #333;
      color: white;
      text-align: center;
      border-radius: 4px;
      padding: 5px;
      position: absolute;
      z-index: 1001;
      right: 45px;
      top: 50%;
      transform: translateY(-50%);
      opacity: 0;
      transition: opacity 0.3s;
      font-size: 12px;
      pointer-events: none;
    }
    
    .tooltip:hover .tooltiptext {
      visibility: visible;
      opacity: 1;
    }
    
    .details-container {
      background-color: white;
      padding: 15px;
      border: 1px solid #ddd;
      border-radius: 4px;
    }
    
    .details-container h3 {
      margin-top: 0;
      border-bottom: 1px solid #eee;
      padding-bottom: 8px;
    }
    
    .transaction-info {
      margin-bottom: 15px;
      font-size: 16px;
    }
    
    pre {
      background-color: #f8f8f8;
      padding: 10px;
      border-radius: 4px;
      overflow: auto;
      max-height: 150px;
    }
    
    .status {
      margin-top: 10px;
      font-weight: bold;
      color: #2B7CE9;
    }
  </style>
</head>
<body>
  <div class="header">
    <h1>Neo4j Transaction Animator</h1>
  </div>
  
  <div class="container">
    <div class="transaction-info">
      Transaction: <span id="tx-counter">0 / 0</span>
    </div>
    
    <div class="graph-wrapper">
      <div id="graph-container" class="graph-container"></div>
      
      <div class="graph-controls" id="graph-controls">
        <div class="tooltip">
          <button class="graph-control-btn" id="zoom-in-btn" onclick="zoomIn()">+</button>
          <span class="tooltiptext">Zoom In</span>
        </div>
        <div class="tooltip">
          <button class="graph-control-btn" id="zoom-out-btn" onclick="zoomOut()">−</button>
          <span class="tooltiptext">Zoom Out</span>
        </div>
        <div class="tooltip">
          <button class="graph-control-btn" id="recenter-btn" onclick="recenterView()">⊙</button>
          <span class="tooltiptext">Recenter View</span>
        </div>
      </div>
    </div>

    <div class="navigation-buttons">
      <button id="prev-btn" onclick="previousTransaction()" disabled>Previous Transaction</button>
      <button id="next-btn" onclick="nextTransaction()" disabled>Next Transaction</button>
    </div>
    
    <div class="control-buttons">
      <button id="load-data-btn" onclick="loadExampleData()">Load Example Data</button>
      <input type="file" id="file-upload" accept=".json" style="display: none;" onchange="handleFileUpload(event)">
      <button id="upload-btn" onclick="document.getElementById('file-upload').click()">Upload JSON</button>
      <button id="reset-btn" onclick="resetVisualization()" disabled>Reset</button>
    </div>
    
    <div class="details-container">
      <h3>Transaction Details</h3>
      <pre id="tx-details">No transaction data loaded. Click "Load Example Data" to start.</pre>
      <div id="status" class="status"></div>
    </div>
  </div>
  
  <script>
    // Global variables
    let transactions = [];
    let currentIndex = 0;
    let nodes = new vis.DataSet();
    let edges = new vis.DataSet();
    let network = null;
    
    // Keep track of edges between node pairs
    const edgeCount = new Map();
    
    function getEdgeSettings(fromNode, toNode, type) {
      const nodeKey = `${fromNode}-${toNode}`;
      const count = edgeCount.get(nodeKey) || 0;
      edgeCount.set(nodeKey, count + 1);
      
      // Only curve if this is not the first edge between these nodes
      if (count === 0) {
        return {
          smooth: {
            enabled: false,
            type: 'continuous'
          },
          length: 250,
          font: {
            size: 12,
            align: 'middle',
            background: 'white',
            strokeWidth: 2,
            strokeColor: 'white'
          }
        };
      }
      
      // Adjust roundness and rotation based on number of edges
      const baseRoundness = 0.2;
      const roundnessStep = 0.15;
      const finalRoundness = baseRoundness + (count * roundnessStep);
      
      return {
        smooth: {
          enabled: true,
          type: count % 2 === 0 ? 'curvedCW' : 'curvedCCW',
          roundness: finalRoundness,
          forceDirection: 'none'
        },
        length: 250,
        font: {
          size: 12,
          align: 'middle',
          background: 'white',
          strokeWidth: 2,
          strokeColor: 'white'
        }
      };
    }
    
    // Initialize the visualization
    function initializeVisualization() {
      const container = document.getElementById('graph-container');
      const data = { nodes, edges };
      const options = {
        nodes: {
          shape: 'dot',
          size: 16,
          font: { size: 14 },
          borderWidth: 2,
          shadow: true,
          fixed: false,
          margin: 15
        },
        edges: {
          width: 2,
          shadow: true,
          smooth: {
            enabled: false,
            type: 'continuous'
          },
          arrows: { 
            to: { 
              enabled: true, 
              scaleFactor: 0.5 
            } 
          },
          font: {
            size: 12,
            align: 'middle',
            background: 'white',
            strokeWidth: 2,
            strokeColor: 'white'
          },
          length: 250
        },
        physics: {
          enabled: true,
          stabilization: {
            enabled: true,
            iterations: 1000,
            updateInterval: 50,
            onlyDynamicEdges: false,
            fit: true,
            proper: true
          },
          barnesHut: {
            gravitationalConstant: -1000,
            centralGravity: 0.3,
            springLength: 200,
            springConstant: 0.04,
            damping: 0.09,
            avoidOverlap: 1
          },
          minVelocity: 0.5,
          maxVelocity: 15,
          solver: 'barnesHut',
          timestep: 0.3
        },
        layout: {
          randomSeed: 42,
          improvedLayout: true,
          clusterThreshold: 150,
          hierarchical: {
            enabled: false
          }
        },
        interaction: {
          dragNodes: true,
          dragView: true,
          zoomView: true,
          selectable: true,
          selectConnectedEdges: true,
          navigationButtons: false,
          keyboard: true,
          hover: true,
          multiselect: true,
          tooltipDelay: 200
        },
        manipulation: {
          enabled: false
        },
        configure: {
          enabled: false
        },
        bounds: {
          used: true,
          box: {
            left: -container.offsetWidth/2 + 50,
            top: -container.offsetHeight/2 + 50,
            right: container.offsetWidth/2 - 50,
            bottom: container.offsetHeight/2 - 50
          }
        }
      };
      
      network = new vis.Network(container, data, options);

      // Make sure controls are properly positioned
      const graphControls = document.getElementById('graph-controls');
      
      // Reposition controls when window resizes
      window.addEventListener('resize', function() {
        if (network && container) {
          network.setOptions({
            bounds: {
              box: {
                left: -container.offsetWidth/2 + 50,
                top: -container.offsetHeight/2 + 50,
                right: container.offsetWidth/2 - 50,
                bottom: container.offsetHeight/2 - 50
              }
            }
          });
          network.fit();
        }
      });
      
      // No need for absolute positioning anymore

      // Calculate initial positions for new nodes
      const containerWidth = container.offsetWidth;
      const containerHeight = container.offsetHeight;
      const centerX = containerWidth / 2;
      const centerY = containerHeight / 2;
      let lastNodePosition = { x: centerX, y: centerY };
      let nodeCount = 0;
      
      function calculateNextPosition() {
        // Limit the radius to ensure nodes stay in view
        const maxRadius = Math.min(containerWidth, containerHeight) / 3;
        const radius = Math.min(150, maxRadius);
        const angle = (nodeCount * (2 * Math.PI / 8)) + (Math.PI / 4);
        nodeCount = (nodeCount + 1) % 8;
        
        return {
          x: centerX + radius * Math.cos(angle),
          y: centerY + radius * Math.sin(angle)
        };
      }

      // Add event listeners for stabilization
      network.on("stabilizationStart", function () {
        updateStatus("Stabilizing graph layout...");
        network.stopSimulation();
        setTimeout(() => {
          network.startSimulation();
        }, 50);
      });

      network.on("stabilizationIterationsDone", function () {
        network.setOptions({ physics: { stabilization: { enabled: false } } });
        network.fit({
          animation: {
            duration: 1000,
            easingFunction: "easeOutQuart"
          }
        });
      });

      network.on("stabilized", function() {
        updateStatus("Graph layout stabilized");
      });

      // Only fit view after adding nodes, not during drag operations
      let fitTimeout = null;
      nodes.on('add', function(event, properties, senderId) {
        if (fitTimeout) clearTimeout(fitTimeout);
        
        // Update positions for newly added nodes
        const newNodes = properties.items;
        newNodes.forEach(nodeId => {
          const position = calculateNextPosition();
          network.moveNode(nodeId, position.x, position.y);
          lastNodePosition = position;
        });

        // Temporarily disable physics during node addition
        network.setOptions({ physics: { enabled: false } });
        
        fitTimeout = setTimeout(() => {
          // Re-enable physics with gentle settings
          network.setOptions({ 
            physics: { 
              enabled: true,
              barnesHut: {
                gravitationalConstant: -500,
                centralGravity: 0.1,
                springLength: 200,
                springConstant: 0.02,
                damping: 0.09
              }
            }
          });
          
          network.fit({
            animation: {
              duration: 1000,
              easingFunction: "easeOutQuart"
            }
          });
        }, 300);
      });

      // Add drag event handlers
      network.on("dragStart", function() {
        if (fitTimeout) clearTimeout(fitTimeout);
        network.setOptions({ physics: { enabled: false } });
      });

      network.on("dragEnd", function(params) {
        if (params.nodes.length > 0) {
          const nodeId = params.nodes[0];
          const position = network.getPositions([nodeId])[nodeId];
          lastNodePosition = position;
        }
        
        // Gently re-enable physics
        setTimeout(() => {
          network.setOptions({ 
            physics: { 
              enabled: true,
              barnesHut: {
                gravitationalConstant: -500,
                centralGravity: 0.1,
                springLength: 200,
                springConstant: 0.02,
                damping: 0.09
              }
            }
          });
        }, 200);
      });

      // Ensure nodes stay in view during stabilization
      network.on("afterDrawing", function() {
        const nodePositions = network.getPositions();
        const viewPosition = network.getViewPosition();
        const scale = network.getScale();
        
        let needsRepositioning = false;
        const boundingBox = {
          left: viewPosition.x - (containerWidth/2)/scale + 50/scale,
          right: viewPosition.x + (containerWidth/2)/scale - 50/scale,
          top: viewPosition.y - (containerHeight/2)/scale + 50/scale,
          bottom: viewPosition.y + (containerHeight/2)/scale - 50/scale
        };
        
        for (const nodeId in nodePositions) {
          const pos = nodePositions[nodeId];
          if (pos.x < boundingBox.left || pos.x > boundingBox.right || 
              pos.y < boundingBox.top || pos.y > boundingBox.bottom) {
            needsRepositioning = true;
            break;
          }
        }
        
        if (needsRepositioning) {
          network.fit({
            animation: {
              duration: 500,
              easingFunction: "easeOutQuad"
            }
          });
        }
      });

      updateStatus("Visualization initialized. Ready to load data.");
    }
    
    // Load example transaction data
    function loadExampleData() {
      updateStatus("Loading example data...");
      
      // Sample transaction data
      transactions = [
        {
          id: "tx1",
          timestamp: "2025-04-05T09:15:00Z",
          query: "CREATE (p:Product {id: 'p1', name: 'Smartphone X1', price: 899.99})",
          changes: {
            nodes: {
              created: [
                {
                  id: "node1",
                  labels: ["Product"],
                  properties: {
                    id: "p1",
                    name: "Smartphone X1",
                    price: 899.99
                  }
                }
              ],
              modified: [],
              deleted: []
            },
            relationships: {
              created: [],
              modified: [],
              deleted: []
            }
          }
        },
        {
          id: "tx2",
          timestamp: "2025-04-05T09:16:30Z",
          query: "CREATE (c:Customer {id: 'c1', name: 'Alice Smith', email: 'alice@example.com'})",
          changes: {
            nodes: {
              created: [
                {
                  id: "node2",
                  labels: ["Customer"],
                  properties: {
                    id: "c1",
                    name: "Alice Smith",
                    email: "alice@example.com"
                  }
                }
              ],
              modified: [],
              deleted: []
            },
            relationships: {
              created: [],
              modified: [],
              deleted: []
            }
          }
        },
        {
          id: "tx3",
          timestamp: "2025-04-05T09:19:00Z",
          query: "MATCH (c:Customer {id: 'c1'}), (p:Product {id: 'p1'}) CREATE (c)-[r:VIEWED {timestamp: datetime()}]->(p)",
          changes: {
            nodes: {
              created: [],
              modified: [],
              deleted: []
            },
            relationships: {
              created: [
                {
                  id: "rel1",
                  type: "VIEWED",
                  startNodeId: "node2",
                  endNodeId: "node1",
                  properties: {
                    timestamp: "2025-04-05T09:19:00Z"
                  }
                }
              ],
              modified: [],
              deleted: []
            }
          }
        },
        {
          id: "tx4",
          timestamp: "2025-04-05T09:22:30Z",
          query: "MATCH (c:Customer {id: 'c1'}), (p:Product {id: 'p1'}) CREATE (c)-[r:PURCHASED {timestamp: datetime(), quantity: 1, total: 899.99}]->(p)",
          changes: {
            nodes: {
              created: [],
              modified: [],
              deleted: []
            },
            relationships: {
              created: [
                {
                  id: "rel2",
                  type: "PURCHASED",
                  startNodeId: "node2",
                  endNodeId: "node1",
                  properties: {
                    timestamp: "2025-04-05T09:22:30Z",
                    quantity: 1,
                    total: 899.99
                  }
                }
              ],
              modified: [],
              deleted: []
            }
          }
        }
      ];
      
      // Reset visualization
      resetVisualization();
      
      // Update UI
      document.getElementById('tx-counter').textContent = `${currentIndex} / ${transactions.length}`;
      updateButtonStates();
      
      updateTransactionDetails();
      
      // Automatically apply the first transaction
      if (transactions.length > 0) {
        nextTransaction();
      }
    }
    
    // Handle file upload
    function handleFileUpload(event) {
      const file = event.target.files[0];
      if (!file) return;

      const reader = new FileReader();
      reader.onload = function(e) {
        try {
          const jsonData = JSON.parse(e.target.result);
          
          // Validate the JSON structure
          if (!Array.isArray(jsonData)) {
            throw new Error("Uploaded file must contain an array of transactions");
          }

          // Basic validation of transaction structure
          jsonData.forEach((tx, index) => {
            if (!tx.id || !tx.timestamp || !tx.query || !tx.changes) {
              throw new Error(`Invalid transaction structure at index ${index}`);
            }
          });

          // If validation passes, load the data
          transactions = jsonData;
          
          // Reset visualization
          resetVisualization();
          
          // Update UI
          document.getElementById('tx-counter').textContent = `${currentIndex} / ${transactions.length}`;
          updateButtonStates();
          
          updateTransactionDetails();
          
          // Automatically apply the first transaction
          if (transactions.length > 0) {
            nextTransaction();
          }
        } catch (error) {
          updateStatus(`Error loading file: ${error.message}`);
          console.error("File upload error:", error);
        }
      };
      reader.readAsText(file);
    }
    
    // Process the next transaction
    function nextTransaction() {
      if (currentIndex >= transactions.length) {
        updateStatus("End of transaction sequence reached.");
        return;
      }
      
      const tx = transactions[currentIndex];
      updateStatus(`Applying transaction ${currentIndex + 1}: ${tx.id}`);
      
      network.physics.options.barnesHut.springConstant = 0.01;
      network.physics.options.barnesHut.damping = 0.12;
      
      // Process node creations with spacing
      if (tx.changes.nodes && tx.changes.nodes.created) {
        tx.changes.nodes.created.forEach((node, index) => {
          const nodeLabel = node.labels.join(':');
          const nodeName = node.properties.name || node.properties.id || 'Unknown';
          
          nodes.add({
            id: node.id,
            label: `${nodeLabel}\n${nodeName}`,
            color: getNodeColor(node.labels),
            margin: 15,
            font: { size: 14, multi: true }
          });
        });
      }
      
      // Process relationship creations with improved edge routing
      if (tx.changes.relationships && tx.changes.relationships.created) {
        tx.changes.relationships.created.forEach(rel => {
          const edgeSettings = getEdgeSettings(rel.startNodeId, rel.endNodeId, rel.type);
          
          edges.add({
            id: rel.id,
            from: rel.startNodeId,
            to: rel.endNodeId,
            label: rel.type,
            ...edgeSettings
          });
        });
      }
      
      // Update current index and UI
      currentIndex++;
      document.getElementById('tx-counter').textContent = `${currentIndex} / ${transactions.length}`;
      updateButtonStates();
      updateTransactionDetails();

      setTimeout(() => {
        network.physics.options.barnesHut.springConstant = 0.01;
        network.physics.options.barnesHut.damping = 0.09;
      }, 1500);

      setTimeout(() => {
        network.fit({
          animation: {
            duration: 1500,
            easingFunction: "easeInOutCubic"
          }
        });
      }, 750);
    }
    
    // Reset the visualization
    function resetVisualization() {
      currentIndex = 0;
      nodes.clear();
      edges.clear();
      document.getElementById('tx-counter').textContent = `${currentIndex} / ${transactions.length}`;
      updateButtonStates();
      updateTransactionDetails();
      updateStatus("Visualization reset.");
    }
    
    // Get color for node based on label
    function getNodeColor(labels) {
      const colorMap = {
        'Product': { background: '#FF9999', border: '#CC0000' },
        'Customer': { background: '#FFCC66', border: '#CC9900' },
        'Order': { background: '#99CC99', border: '#009900' },
        'Category': { background: '#9999FF', border: '#0000CC' }
      };
      
      for (const label of labels) {
        if (colorMap[label]) {
          return colorMap[label];
        }
      }
      
      return { background: '#D2E5FF', border: '#2B7CE9' };
    }
    
    // Update transaction details display
    function updateTransactionDetails() {
      const detailsElement = document.getElementById('tx-details');
      
      if (currentIndex === 0 || transactions.length === 0) {
        detailsElement.textContent = "No transaction applied yet.";
        return;
      }
      
      const tx = transactions[currentIndex - 1];
      const details = JSON.stringify(tx, null, 2);
      detailsElement.textContent = details;
    }
    
    // Update status message
    function updateStatus(message) {
      const statusElement = document.getElementById('status');
      statusElement.textContent = message;
      console.log(message);
    }
    
    // Process the previous transaction
    function previousTransaction() {
      if (currentIndex <= 1) {
        updateStatus("At the beginning of transaction sequence.");
        return;
      }

      const tx = transactions[currentIndex - 1];
      
      // Update edge count when removing edges
      if (tx.changes.relationships && tx.changes.relationships.created) {
        tx.changes.relationships.created.forEach(rel => {
          const nodeKey = `${rel.startNodeId}-${rel.endNodeId}`;
          const count = edgeCount.get(nodeKey);
          if (count > 1) {
            edgeCount.set(nodeKey, count - 1);
          } else {
            edgeCount.delete(nodeKey);
          }
        });
      }
      
      // Undo node creations (remove them)
      if (tx.changes.nodes && tx.changes.nodes.created) {
        tx.changes.nodes.created.forEach(node => {
          nodes.remove(node.id);
        });
      }
      
      // Undo node modifications (restore previous state)
      if (tx.changes.nodes && tx.changes.nodes.modified) {
        tx.changes.nodes.modified.forEach(node => {
          // Get the node's state from the previous transaction
          const prevTx = transactions[currentIndex - 2];
          const prevNode = prevTx.changes.nodes.created.find(n => n.id === node.id) ||
                          prevTx.changes.nodes.modified.find(n => n.id === node.id);
          
          if (prevNode) {
            const nodeLabel = prevNode.labels.join(':');
            const nodeName = prevNode.properties.name || prevNode.properties.id || 'Unknown';
            
            nodes.update({
              id: prevNode.id,
              label: `${nodeLabel}\n${nodeName}`,
              color: getNodeColor(prevNode.labels)
            });
          }
        });
      }
      
      // Undo node deletions (restore them)
      if (tx.changes.nodes && tx.changes.nodes.deleted) {
        tx.changes.nodes.deleted.forEach(nodeId => {
          // Find the node's last known state before deletion
          for (let i = currentIndex - 2; i >= 0; i--) {
            const prevTx = transactions[i];
            const prevNode = prevTx.changes.nodes.created.find(n => n.id === nodeId) ||
                            prevTx.changes.nodes.modified.find(n => n.id === nodeId);
            
            if (prevNode) {
              const nodeLabel = prevNode.labels.join(':');
              const nodeName = prevNode.properties.name || prevNode.properties.id || 'Unknown';
              
              nodes.add({
                id: prevNode.id,
                label: `${nodeLabel}\n${nodeName}`,
                color: getNodeColor(prevNode.labels)
              });
              break;
            }
          }
        });
      }
      
      // Undo relationship creations (remove them)
      if (tx.changes.relationships && tx.changes.relationships.created) {
        tx.changes.relationships.created.forEach(rel => {
          edges.remove(rel.id);
        });
      }
      
      // Undo relationship deletions (restore them)
      if (tx.changes.relationships && tx.changes.relationships.deleted) {
        tx.changes.relationships.deleted.forEach(relId => {
          // Find the relationship's last known state before deletion
          for (let i = currentIndex - 2; i >= 0; i--) {
            const prevTx = transactions[i];
            const prevRel = prevTx.changes.relationships.created.find(r => r.id === relId) ||
                           prevTx.changes.relationships.modified.find(r => r.id === relId);
            
            if (prevRel) {
              edges.add({
                id: prevRel.id,
                from: prevRel.startNodeId,
                to: prevRel.endNodeId,
                label: prevRel.type
              });
              break;
            }
          }
        });
      }
      
      // Update current index and UI
      currentIndex--;
      document.getElementById('tx-counter').textContent = `${currentIndex} / ${transactions.length}`;
      updateButtonStates();
      updateTransactionDetails();
      updateStatus(`Moved back to transaction ${currentIndex}`);

      // Ensure the view is updated
      setTimeout(() => {
        network.fit({
          animation: {
            duration: 1000,
            easingFunction: "easeInOutQuad"
          }
        });
      }, 500);
    }

    // Update UI button states
    function updateButtonStates() {
      const prevBtn = document.getElementById('prev-btn');
      const nextBtn = document.getElementById('next-btn');
      const resetBtn = document.getElementById('reset-btn');
      
      prevBtn.disabled = currentIndex <= 1;
      nextBtn.disabled = currentIndex >= transactions.length;
      resetBtn.disabled = transactions.length === 0;
    }
    
    // Zoom and center control functions
    function zoomIn() {
      if (!network) return;
      
      const currentScale = network.getScale();
      network.moveTo({
        scale: currentScale * 1.2,
        animation: {
          duration: 300,
          easingFunction: 'easeOutQuad'
        }
      });
    }
    
    function zoomOut() {
      if (!network) return;
      
      const currentScale = network.getScale();
      network.moveTo({
        scale: currentScale / 1.2,
        animation: {
          duration: 300,
          easingFunction: 'easeOutQuad'
        }
      });
    }
    
    function recenterView() {
      if (!network) return;
      
      const selectedNodes = network.getSelectedNodes();
      
      if (selectedNodes.length > 0) {
        // Center on the first selected node
        network.focus(selectedNodes[0], {
          scale: 1.2,
          animation: {
            duration: 500,
            easingFunction: 'easeOutQuad'
          }
        });
      } else {
        // No selected node, fit the entire graph
        network.fit({
          animation: {
            duration: 500,
            easingFunction: 'easeOutQuad'
          }
        });
      }
    }
    
    // Initialize when page loads
    window.onload = function() {
      initializeVisualization();
    };
  </script>
</body>
</html>